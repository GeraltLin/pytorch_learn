# Tensor（张量）类似于NumPy的ndarray，但还可以在GPU上使用来加速计算。
import torch

# 创建一个没有初始化的5×3矩阵:

x = torch.empty(5, 3)
print(x)
# tensor([[7.7447e+31, 1.6545e+22, 1.0806e-32],
#         [1.3563e-19, 1.3563e-19, 2.8177e+20],
#         [1.6929e+22, 2.0535e-19, 5.5578e-11],
#         [1.7895e+28, 1.6930e+22, 1.9517e-19],
#         [1.7256e+25, 6.3828e+28, 6.4678e+19]])

# 创建一个随机初始化矩阵：
x = torch.rand(5, 3)
print(x)
# tensor([[0.5307, 0.9752, 0.5376],
#         [0.2789, 0.7219, 0.1254],
#         [0.6700, 0.6100, 0.3484],
#         [0.0922, 0.0779, 0.2446],
#         [0.2967, 0.9481, 0.1311]])

# 构造一个填满0且数据类型为long的矩阵:
x = torch.zeros(5, 3, dtype=torch.long)
print(x)
# tensor([[0, 0, 0],
#         [0, 0, 0],
#         [0, 0, 0],
#         [0, 0, 0],
#         [0, 0, 0]])

# 直接从数据构造张量：
x = torch.tensor([1,3])
print(x)
# tensor([1, 3])

# 或者根据已有的tensor建立新的tensor。除非用户提供新的值，否则这些方法将重用输入张量的属性，例如dtype等
x = x.new_ones(5, 3, dtype=torch.double)      # new_* methods take in sizes
print(x)
# tensor([[1., 1., 1.],
#         [1., 1., 1.],
#         [1., 1., 1.],
#         [1., 1., 1.],
#         [1., 1., 1.]], dtype=torch.float64)

x = torch.randn_like(x, dtype=torch.float)    # 重载 dtype!
print(x)                                      # 结果有相同的size
# tensor([[ 1.4992,  0.3871, -1.9467],
#         [ 2.3272,  1.1023, -0.1169],
#         [ 1.2763,  0.8576, -0.8535],
#         [ 1.5489, -0.7742,  1.0881],
#         [-0.7718, -2.0013,  0.6638]])

# 获取它的形状：
print(x.size()) # torch.Size([5, 3])
